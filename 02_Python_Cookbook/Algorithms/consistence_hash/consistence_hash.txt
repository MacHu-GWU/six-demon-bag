Consistence Hash (一致性Hash算法)


背景介绍
--------

一致性Hash算法常被用于分布式系统的负载均衡中。我们用一个例子来说明负载均衡问题的模型。

我们有一台下载服务器，上面有几百万首歌的MP3音乐资源。为了应付大量用户的同时下载，我们肯定是不能仅仅使用一台服务器的。工业界的做法是：设置一台master服务器，然后许多cache服务器。主服务器上的任何内容会被同步到cache服务器上。然后用户对主服务器上资源的下载请求，会被均匀的分布到不同的cache服务器上，这样负载就被均衡了。

一个简单的负载均衡的实现就是hash映射。hash映射是一种能将任意类型，大小的输入映射成一个字符串或者整数的函数。得到的字符串或者整数被称作“hash值”。例如“取任意输入流的第一个英文字母”就是一个简单的hash函数。例如我们有26个负载服务器，如果用户Jack和Tom同时发起请求，那么Jack的下载就会在J服务器上，Tom的下载就会在T服务器上进行。

在负载均衡中，我们主要要满足下面几个需求：
1. 用户的请求会被尽量均匀的分布到若干个服务器上。
    显然，我们刚才的首字母hash就是个很糟糕的算法，因为这样会导致S服务器负荷远远大于其他服务器（英文中S开头的频率最高）。假设我们有26个服务器，那么我们用用户发起请求的时间戳毫秒数（2014-01-01 06:00:00.123中123就是毫秒数）除以26所剩下的余数作为hash值就是一个不错的选择。用户的负载肯定能随机的被分布到我们的缓存服务器上。


案例分析
--------

情景假设：
    我们有1000G的mp3资源，我们要架设一个下载服务器，使得大量的用户能同时稳定的下载音乐资源。

面对的挑战：
    1. 同一台服务器的带宽有一个带宽上线，如果我们要满足1000人同时以1MB/s的速度下载，我们就需要1GB/s的贷款。而一台服务器肯定做不到这一点。
        - 粗略方案：建立多个服务器的镜像，让用户下载需求分流。

    2. 如果我们为服务器建立n个镜像，那么我们所需要的存储空间就需要1000G * n，这是一笔庞大的开销。
        - 粗略方案：每个镜像服务器不储存全部的资源，而只储存部分资源。我们需要分流的是带宽，而不是数据本身。此时我们不再称“镜像”服务器，而是称“缓存”服务器(下称cache)

    3. 多个镜像服务器中由于随机的有机器挂掉，和我们要新增分流镜像服务器时，负载均衡的问题。
        - 下面再详细展开讨论。

第一期方案：
    假设每台服务器的网络带宽是10MB/s，那么我们至少要1000 * 1 / 10 = 100台服务器，这属于刚性需求。

    我们可以设置100台cache，每台cache有1G的数据。cache服务器的编号从0到99。我们对所有的音乐文件做hash，hash值除以100的余数是几，我们就把这个音乐文件放到编号为几的cache缓存服务器上。

    这种传统的hash方案有一个致命的问题。例如我们编号0的服务器挂掉了，那么我们就需要重新对所有的资源用除以 99重新进行分配。所以，一致hash算法应运而生。

一致hash算法
    
    首先我们找一个hash算法能将任意对象hash到0到4294967296（2^32减1）之间的整数上。我们可以把可能的hash值空间想象成一个闭合的环形。从0开始，到4294967296结束。

    然后将这100台cache的ip地址hash到这个环上，成为100个节点（下称Node），由于hash算法的随机性，虽然不保证这100个点均匀分布，但是也不会差的太离谱。例如我们这100个服务器的hash值分别是0, 42949673*1, 42949673*2, ..., 42949673*99。

    然后我们将这1000个G的音乐文件，全部都hash，然后我们将刚才的100个Node的中大于等于音乐文件的hash值且环形距离最近的那个节点的hash值，当做这个音乐文件的hash值。

    至此我们的master服务器最终得到了一个非常大的表，将每个音乐文件id映射到服务器的id上。

一致hash算法在节点被删除之后的表现
    假设我们编号0的服务器挂掉了，那么我们只要把原来编号为0的服务器上的资源拷贝到环上0号服务器的下一个服务器上，然后把大表中原来服务器id为0的值改成下一个服务器的id值即可。

一致hash算法在添加新节点之后的表现
    假设我们在插入了一个新服务器100位于编号为id1和id2的服务器之间，那么我们只需要对id1服务器上的资源进行扫描，然是hash值大于新服务器的hash值的文件，都被迁移到新服务器上即可。

ref = http://sofar.blog.51cto.com/353572/1398424