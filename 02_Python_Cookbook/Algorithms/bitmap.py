##################################
#encoding=utf8                   #
#version =py27, py33             #
#author  =sanhe                  #
#date    =2014-10-29             #
#                                #
#    (\ (\                       #
#    ( -.-)o    I am a Rabbit!   #
#    o_(")(")                    #
#                                #
##################################

from __future__ import print_function
import math

""" 基本介绍 """
# ## 位图法
# 位图法常常用于判定集合中元素的存在，重复，一次性。
# 位图法适用于大规模数据，但数据状态又不是很多的情况。通常是用来判断某个数据存不存在，如可标记1为存在，0为不存在

""" 简单的bitmap数据结构演示 """
# ## 建立最简单的bitmap：
# 给定array = [1,5,7,9,13],由于最大的数是13,那么就给分配一个大小为16的内存。比如5存在，那么就给第5个位置上置1
# 最后生成的位图数据结构如下： [1][0][0][0][1] [0][1][0][1][0] [0][0][1][0][0] [0]
# 而在访问数据的时候，由于值本身就是指针，所以取数据的时间复杂度是O(1)。在本例中，给每一个可能存在的数字只分配了1bit
# 的内存空间，所以只能表示0,1两种状态。如果分配了2bit，则我们可以表示数字的4种状态。

""" 简单例题 """
# ## 例题1：  一个长度为n的整数数组，里面的数是乱序的。再给一个数，看这个数在该数组中是否存在 ##
# 
# 普通青年:
#         遍历数组，一个个对比,那么时间复杂度为n。但是如果给一个数，判断是否存在这样的操作要反复进行很多次，那么
#         每一次的时间复杂度都是n。假设有k个数要这么干，那么总时间就是k*n
#  
# 文艺青年：
#         首先对数组进行排序，然后进行二分查找。那么排序时间是O(n*log(n))。查找时间是O(log(n))。只做一次的话的确
#         没有普通青年快，但是如果要做k次，那么总时间就是n*log(n) + k*log(n)。当k大于log(n)的时候，文艺青年已经
#         比普通青年快很多了。
#         
# 2B青年：
#         用位图法对整个数组进行扫描，如果已知数是从1到1024，那么就需要一个1024位长的内存。例如扫描到数字5，就把内存
#         的第5个位置置1，如果又碰到5则继续保持1不变。最后判断是否存在只需要复杂度O(1)，看对应位置是0还是1即可。那么
#         总预处理扫描的时间复杂度是O(n),查找的复杂度是O(1)。所以总时间是k+n。时间复杂度是所有算法中最优的。

""" 讨论 """
# 根据以上例题可以看到，位图最关键的就是，如果已经知道数据的范围range(min,max)，那么我们就需要一个大小为 max-min的内存空间
# 如果事先不知道数据的范围，则我们就要根据数据的类型所可能的最大范围去构造位图。所以int32就需要 2^32/8 = 536MB的内存空间。
# 这就是为什么说： “位图法适用于大规模数据，但数据状态又不是很多的情况。” 的原因


# 问题：
# 在2.5亿个整数中找出不重复的整数，注：内存不足以容纳这2.5亿个整数。
# 
# 解决思路：
# 对于win32系统中，整数是用32个位来表示的，即4个字节. 2.5亿个整数需要： 2.5*10e8 * 4/1000,000,000 = 1G内存
# 因为已经预先知道整数的范围是有 2^32 = 4.3亿个整数

def logx( x, y ): ## logx (y)
    return math.log(y) / math.log(x)

k = 10 ## 重复k次这种查找
n = 1024 ## 有多少个个数
print(k * n)
print(n * logx(2, n)+ k * logx(2, n))
print(k + n)
